[["index.html", "Functions and Iterations Overview", " Functions and Iterations Reed Kenny and Tara Pozzi 2023-05-10 Overview This is a mini-lecture on function-writing and iteration using data from the Global Biodiversity Information Facility. "],["functions-can-be-like-personalized-mini-packages.html", "Functions can be like personalized Mini Packages", " Functions can be like personalized Mini Packages There are two main uses for functions that I can think of right now, one is to make yourself nifty little mini packages and the other is to make iteration easier. Let’s start with the first instance You may often find yourself in a situation where you need to do the same thing (or set of things) in R, over and over again. One thing that I often want to do is to look at a plant species range map. I generally pull occurence data from the Global Biodiversity Information Facility (GBIF), limiting the search to locations correspoding to a museum collection. This does not take many lines of code but I usually have to look it up. To make my life easier I can write a function to do this task and save the function to be accessible in any of my R sessions. The first step is to call GBIF and import the dataset of species occurrences library(rgbif) library(ggplot2) GBIF_Frax = occ_search(scientificName = &quot;Fraxinus velutina&quot;, hasCoordinate = TRUE, basisOfRecord = &quot;PRESERVED_SPECIMEN&quot;) Then I need to select just the data not the metadata that comes with Frax_dat &lt;- GBIF_Frax$data Then I can plot the occurrences wm &lt;- borders(&quot;world&quot;, colour=&quot;gray50&quot;, fill=&quot;gray50&quot;) #map backgroud ggplot()+ coord_fixed() + wm + geom_point(data = Frax_dat, aes(x = decimalLongitude, y = decimalLatitude), colour = &quot;darkred&quot;, size = 0.5) + theme_bw() + ggtitle(Frax_dat$scientificName) This is a fairly easy piece of code to turn into a function. If I were to do this with a different species, the only piece of information that changes is the speices name. So in my function, that is what I specify as the variable. dist_map &lt;- function(x) { GBIFdata = occ_search(scientificName = x, limit = 300, hasCoordinate = TRUE, basisOfRecord = &quot;PRESERVED_SPECIMEN&quot;) dat = GBIFdata$data wm = borders(&quot;world&quot;, colour=&quot;gray50&quot;, fill=&quot;gray50&quot;) #map backgroud p = ggplot()+ coord_fixed() + wm + geom_point(data = dat, aes(x = decimalLongitude, y = decimalLatitude), colour = &quot;darkred&quot;, size = 0.5) + theme_bw() + ggtitle(dat$scientificName) plot_list = p # save plot return(p) } Now when I want a species range map I can just use one line of code dist_map(&quot;Fremontodendron californicum&quot;) I can save that function to a separate script if I want to use it again in the future. I have a directory for my functions “~Desktop/R-functions” where I saved it. Now I can call it in any of my other script using the source() function. source(&quot;~/Documents/R_Projects/D-RUG/iterations/dist_map.R&quot;) dist_map(&quot;Fremontodendron californicum&quot;) "],["iteration.html", "Iteration 0.1 For Loops", " Iteration Up until this point, we have been able to download and map the range of one plant species at a time. However, what if we want to download the data for and create a range map of several plant species? This is where iteration comes into play! Essentially, iteration is a way of running the code you wrote in your function multiple times. So if you ever find yourself copy-pasting, then you could likely benefit from using iteration. There are three main ways to do iterations: For Loops Apply functions Map functions 0.1 For Loops For Loops repeat the code you’ve written across different input values (i). For example, for(i in 1:10) { print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 We will need to create an empty dataframe to save the results of the loop results &lt;- rep(NA, 10) for(i in 1:10) { results[i] &lt;- i*10 } Now let’s try to translate this to the example Reed shared on plotting the range of plant species. Let’s keeping working with that example, but bring in multiple Fraxinus species. To do so, I’m going to create a new function for downloading the data. library(rgbif) library(ggplot2) library(tidyverse) ## ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ── ## ✔ tibble 3.1.8 ✔ dplyr 1.1.0 ## ✔ tidyr 1.3.0 ✔ stringr 1.5.0 ## ✔ readr 2.1.3 ✔ forcats 0.5.2 ## ✔ purrr 1.0.1 ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() # Let&#39;s create one datafame to start download_data &lt;- function(x){ GBIFdata = occ_search(scientificName = x, limit = 300, hasCoordinate = TRUE, basisOfRecord = &quot;PRESERVED_SPECIMEN&quot;) dat &lt;- GBIFdata$data return(dat) } # test df_FP &lt;- download_data(&quot;Fraxinus pallisiae&quot;) # Now let&#39;s try bringing in multiple species ## create list of all Fraxinus species species_names &lt;- read.csv(&quot;fraxinus_species.csv&quot;) %&gt;% dplyr::select(Name)%&gt;% as.list() species_names ## $Name ## [1] &quot;Fraxinus albicans Buckley&quot; &quot;Fraxinus americana&quot; ## [3] &quot;Fraxinus angustifolia&quot; &quot;Fraxinus anomala&quot; ## [5] &quot;Fraxinus apertisquamifera&quot; &quot;Fraxinus baroniana&quot; ## [7] &quot;Fraxinus berlandieriana&quot; &quot;Fraxinus bornmuelleri&quot; ## [9] &quot;Fraxinus bungeana&quot; &quot;Fraxinus caroliniana&quot; ## [11] &quot;Fraxinus chiisanensis&quot; &quot;Fraxinus chinensis&quot; ## [13] &quot;Fraxinus cuspidata&quot; &quot;Fraxinus depauperata&quot; ## [15] &quot;Fraxinus dimorpha&quot; &quot;Fraxinus dipetala&quot; ## [17] &quot;Fraxinus excelsior&quot; &quot;Fraxinus ferruginea&quot; ## [19] &quot;Fraxinus floribunda&quot; &quot;Fraxinus gooddingii&quot; ## [21] &quot;Fraxinus greggii&quot; &quot;Fraxinus griffithii&quot; ## [23] &quot;Fraxinus hookeri&quot; &quot;Fraxinus hubeiensis&quot; ## [25] &quot;Fraxinus insularis&quot; &quot;Fraxinus lanuginosa&quot; ## [27] &quot;Fraxinus latifolia&quot; &quot;Fraxinus longicuspis&quot; ## [29] &quot;Fraxinus malacophylla&quot; &quot;Fraxinus mandshurica&quot; ## [31] &quot;Fraxinus micrantha&quot; &quot;Fraxinus nigra&quot; ## [33] &quot;Fraxinus odontocalyx&quot; &quot;Fraxinus ornus&quot; ## [35] &quot;Fraxinus pallisiae&quot; &quot;Fraxinus papillosa&quot; ## [37] &quot;Fraxinus paxiana&quot; &quot;Fraxinus pennsylvanica&quot; ## [39] &quot;Fraxinus platypoda&quot; &quot;Fraxinus potosina&quot; ## [41] &quot;Fraxinus pringlei&quot; &quot;Fraxinus profunda&quot; ## [43] &quot;Fraxinus punctata&quot; &quot;Fraxinus purpusii&quot; ## [45] &quot;Fraxinus quadrangulata&quot; &quot;Fraxinus raibocarpa&quot; ## [47] &quot;Fraxinus reflexiflora&quot; &quot;Fraxinus rufescens&quot; ## [49] &quot;Fraxinus schiedeana&quot; &quot;Fraxinus sieboldiana&quot; ## [51] &quot;Fraxinus sogdiana&quot; &quot;Fraxinus stenolepis&quot; ## [53] &quot;Fraxinus stylosa&quot; &quot;Fraxinus suaveolens&quot; ## [55] &quot;Fraxinus trifoliolata&quot; &quot;Fraxinus uhdei&quot; ## [57] &quot;Fraxinus velutina&quot; &quot;Fraxinus xanthoxyloides&quot; ## [59] &quot;Fraxinus ×borzae&quot; &quot;Fraxinus ×cataubiensis&quot; ## [61] &quot;Fraxinus ×hybrida&quot; &quot;Fraxinus ×rehderiana&quot; ## [63] &quot;Fraxinus ×veltheimii&quot; ## there&#39;s a lot so for time sake let&#39;s just select a few species species &lt;- c(&quot;Fraxinus albicans Buckley&quot;, &quot;Fraxinus americana&quot;, &quot;Fraxinus angustifolia&quot;, &quot;Fraxinus anomala&quot;, &quot;Fraxinus apertisquamifera&quot;) # iterate over each species for(i in species) { download_data(i) } ## downloads data for all species but they are not saved! ## create a dataframe to save data into for(i in species) { df &lt;- download_data(i) } ## oops! not all of our datasets save... looks like it only saved the data for the last i ## we need to create an empty dataframe for the loop to fill! comb_species_test &lt;- data.frame() for(i in species) { df &lt;- download_data(i) comb_species_test &lt;- bind_rows(comb_species_test, df) } ## now we get this error that numbers of columns of arguments do not match ### Let&#39;s just select columns of interest across datasets: colnames(df_FP) ## [1] &quot;key&quot; &quot;scientificName&quot; ## [3] &quot;decimalLatitude&quot; &quot;decimalLongitude&quot; ## [5] &quot;issues&quot; &quot;datasetKey&quot; ## [7] &quot;publishingOrgKey&quot; &quot;installationKey&quot; ## [9] &quot;publishingCountry&quot; &quot;protocol&quot; ## [11] &quot;lastCrawled&quot; &quot;lastParsed&quot; ## [13] &quot;crawlId&quot; &quot;hostingOrganizationKey&quot; ## [15] &quot;basisOfRecord&quot; &quot;occurrenceStatus&quot; ## [17] &quot;establishmentMeans&quot; &quot;taxonKey&quot; ## [19] &quot;kingdomKey&quot; &quot;phylumKey&quot; ## [21] &quot;classKey&quot; &quot;orderKey&quot; ## [23] &quot;familyKey&quot; &quot;genusKey&quot; ## [25] &quot;speciesKey&quot; &quot;acceptedTaxonKey&quot; ## [27] &quot;acceptedScientificName&quot; &quot;kingdom&quot; ## [29] &quot;phylum&quot; &quot;order&quot; ## [31] &quot;family&quot; &quot;genus&quot; ## [33] &quot;species&quot; &quot;genericName&quot; ## [35] &quot;specificEpithet&quot; &quot;taxonRank&quot; ## [37] &quot;taxonomicStatus&quot; &quot;iucnRedListCategory&quot; ## [39] &quot;continent&quot; &quot;year&quot; ## [41] &quot;month&quot; &quot;day&quot; ## [43] &quot;eventDate&quot; &quot;modified&quot; ## [45] &quot;lastInterpreted&quot; &quot;license&quot; ## [47] &quot;identifier&quot; &quot;facts&quot; ## [49] &quot;relations&quot; &quot;institutionKey&quot; ## [51] &quot;isInCluster&quot; &quot;recordedBy&quot; ## [53] &quot;identifiedBy&quot; &quot;geodeticDatum&quot; ## [55] &quot;class&quot; &quot;countryCode&quot; ## [57] &quot;recordedByIDs&quot; &quot;identifiedByIDs&quot; ## [59] &quot;country&quot; &quot;rightsHolder&quot; ## [61] &quot;eventID&quot; &quot;identifier.1&quot; ## [63] &quot;institutionID&quot; &quot;county&quot; ## [65] &quot;municipality&quot; &quot;locality&quot; ## [67] &quot;collectionCode&quot; &quot;gbifID&quot; ## [69] &quot;occurrenceID&quot; &quot;taxonID&quot; ## [71] &quot;catalogNumber&quot; &quot;collectionID&quot; ## [73] &quot;identificationID&quot; &quot;name&quot; ## [75] &quot;elevation&quot; &quot;stateProvince&quot; ## [77] &quot;references&quot; &quot;otherCatalogNumbers&quot; ## [79] &quot;associatedOccurrences&quot; &quot;recordNumber&quot; ## [81] &quot;habitat&quot; &quot;verbatimEventDate&quot; ## [83] &quot;http...unknown.org.recordID&quot; &quot;institutionCode&quot; ## [85] &quot;rights&quot; &quot;startDayOfYear&quot; ## [87] &quot;occurrenceRemarks&quot; &quot;reproductiveCondition&quot; ## [89] &quot;higherClassification&quot; &quot;collectionKey&quot; ## [91] &quot;preparations&quot; &quot;http...unknown.org.recordEnteredBy&quot; ## [93] &quot;verbatimElevation&quot; &quot;networkKeys&quot; ## [95] &quot;individualCount&quot; &quot;nomenclaturalCode&quot; ## [97] &quot;verbatimCoordinateSystem&quot; ### Columns we want: &quot;scientificName&quot;, &quot;decimalLatitude&quot;,&quot;decimalLongitude&quot; ## Update function download_data_updated &lt;- function(x){ GBIFdata &lt;- occ_search(scientificName = x, limit = 300, hasCoordinate = TRUE, basisOfRecord = &quot;PRESERVED_SPECIMEN&quot;) dat &lt;- GBIFdata$data dat &lt;- tryCatch( # this tells R to skip over any dataframes that did not have the columns of interest {dat %&gt;% filter(scientificName != &quot;NA&quot;) %&gt;% #get rid of species name with &quot;NA&quot; dplyr::select(scientificName, decimalLatitude, decimalLongitude)}, error=function(error_message) { message(&quot;Missing column.&quot;) message(&quot;And below is the error message from R:&quot;) message(error_message) return(NA)}) return(dat) } ## Run for loop again and see if it works comb_species &lt;- data.frame() for(i in species) { df &lt;- download_data_updated(i) comb_species &lt;- bind_rows(comb_species, df) } Another option for iteration are apply functions in base R. Check out this tutorial for more information: https://ademos.people.uic.edu/Chapter4.html. They often run faster than for loops &amp; can be a lot simpler to set up! ?apply # just the apply function requires a matrix or dataframe to loop over, but this isn&#39;t the format of our input value which is a list...let&#39;s look at other options! ?lapply ?sapply comb_species_apply &lt;- lapply(species, FUN = download_data) #spits out a list! # how to go from list to dataframe? # do.call calls the function you specify and runs it on the next argument comb_species_apply_df &lt;- do.call(&quot;bind_rows&quot;, comb_species_apply) #this will turn the list into a dataframe # this also helps with iterating through mulitple files Apply functions are very handy, but for those dedicated to tidyverse you might be interested in the map family of functions from the purrr package (which is in the tidyverse suite of packages). Check out this tutorial for more: https://jennybc.github.io/purrr-tutorial/ ?purrr::map comb_species_map &lt;- purrr::map(species, .f = download_data) comb_species_map_df &lt;- do.call(&quot;bind_rows&quot;, comb_species_apply) For fun, let’s see how the timing compares between the for loop and the apply functions. ## For Loop system.time({ rm(comb_species) comb_species &lt;- data.frame() for(i in species) { df &lt;- download_data(i) comb_species &lt;- bind_rows(comb_species, df) }}) ## user system elapsed ## 5.801 0.130 11.406 ## Apply system.time(comb_species_apply &lt;- lapply(species, FUN = download_data)) ## user system elapsed ## 5.728 0.105 10.912 Now let’s make a nice plot! wm = borders(&quot;world&quot;, colour=&quot;gray50&quot;, fill=&quot;gray50&quot;) #map backgroud ggplot()+ coord_fixed() + wm + geom_point(data = comb_species, aes(x = decimalLongitude, y = decimalLatitude, color = scientificName),size = 0.5) + theme_bw() + theme(legend.position = &quot;bottom&quot;) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
